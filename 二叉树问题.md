### 二叉树问题

#### 树的子结构
输入两棵二叉树A，B，判断B是不是A的子结构。我们约定空树不是任意一个树的子结构，只要求是子结构，并不要求是子树，两者的判断条件不一样。
```cpp
//二叉树先序遍历
bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
{
    if(pRoot1 == NULL || pRoot2 == NULL)    return false;
    if(isSubStructureTree(pRoot1, pRoot2))    return true;
    else return HasSubtree(pRoot1->left, pRoot2) || HasSubtree(pRoot1->right, pRoot2);
}

//先在树1中找到和树2根结点值相等的结点，然后再判断是否为子结构
bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
{
    bool result = false;
    if(pRoot1 && pRoot2)
    {
        if(pRoot1->val == pRoot2->val)
            result = isSubStructureTree(pRoot1, pRoot2);
        if(!result)
            result = HasSubtree(pRoot1->left, pRoot2);
        if(!result)
            result = HasSubtree(pRoot1->right, pRoot2);
    }
    return result;
}

//判断树2是否为树1的子结构
bool isSubStructureTree(TreeNode* pNode1, TreeNode* pNode2)
{
    if(pNode2 == NULL)  //如果遍历到树2的空节点，直接返回true
        return true;
    else if(pNode1 == NULL)
        return false;
    else if(pNode1->val != pNode2->val)
        return false;
    return isSubStructureTree(pNode1->left, pNode2->left) && isSubStructureTree(pNode1->right, pNode2->right);
}
```

#### 二叉树的镜像
操作给定的二叉树，将其变换为源二叉树的镜像。

```cpp
/**
 * 二叉树的镜像定义：源二叉树   
    	    8  
    	   /  \  
    	  6   10  
    	 / \  / \
    	5  7 9 11
    	镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11 9 7  5 
 */

void Mirror(TreeNode *pRoot) 
{
    if(pRoot == NULL)    return;
    if(!pRoot->left && !pRoot->right)    return;
    TreeNode *temp = pRoot->left;
    pRoot->left = pRoot->right;
    pRoot->right = temp;
    Mirror(pRoot->left);
    Mirror(pRoot->right);
}
```